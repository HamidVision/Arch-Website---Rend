<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Matrix Binary Rain â€“ Rumi encoded</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { background:#fff; overflow:hidden; height:100vh; width:100vw; }

    /* canvas stays behind content, right half only */
    #matrixCanvas {
      position: fixed; inset: 0;
      width:100%; height:100%;
      pointer-events:none; z-index:1;
    }
  </style>
</head>
<body>
  <canvas id="matrixCanvas"></canvas>

  <script>
    (() => {
      const canvas = document.getElementById('matrixCanvas');
      const ctx = canvas && canvas.getContext ? canvas.getContext('2d') : null;
      if (!canvas || !ctx) {
        console.error('Matrix rain: canvas 2D context not available.');
        return;
      }

      // ===== Binary source: Rumi's quote =====
      const QUOTE = "You were born with wings. You are not meant for crawling";

      function textToBits(str){
        const bits = [];
        for (let i=0; i<str.length; i++){
          const code = str.charCodeAt(i);
          const b = code.toString(2).padStart(8,'0');
          for (let j=0; j<b.length; j++) bits.push(b[j]);
        }
        return bits;
      }

      const ALL_BITS = textToBits(QUOTE);

      function splitBits(bits, segments){
        const out = [];
        const size = Math.ceil(bits.length / segments);
        for (let i=0; i<segments; i++){
          const start = i*size;
          const end = Math.min(bits.length, start+size);
          const seg = bits.slice(start, end);
          if (seg.length === 0) break;
          out.push(seg);
        }
        return out;
      }

      // ===== appearance & motion =====
      let fontSize = 16;
      const rightRatio = 0.5;
      const minSpeed = 80;
      const maxSpeed = 220;
      const trailLenMin = 10;
      const trailLenMax = 24;
      const fadeStrength = 0.12;

      const headColor = 'rgba(0,0,0,0.85)';
      const trailColor = (op) => `rgba(0,0,0,${op})`;

      let rightStart = 0;
      let columns = 0;
      let columnWidth = 0;

      let streams = [];
      let segments = [];

      function rand(min, max){ return min + Math.random() * (max - min); }
      function randInt(min, max){ return Math.floor(rand(min, max + 1)); }

      function resize(){
        const w = Math.max(1, window.innerWidth || document.documentElement.clientWidth || 1);
        const h = Math.max(1, window.innerHeight || document.documentElement.clientHeight || 1);
        canvas.width = w; canvas.height = h;

        columnWidth = Math.max(1, Math.floor(fontSize));
        rightStart  = Math.min(Math.floor(w * rightRatio), w - columnWidth);
        const usable = Math.max(0, w - rightStart);
        columns = Math.max(1, Math.floor(usable / columnWidth));

        const segCount = Math.max(3, Math.min(12, Math.ceil(columns / 6)));
        segments = splitBits(ALL_BITS, segCount);

        streams = Array.from({ length: columns }, (_, i) => {
          const len = randInt(trailLenMin, trailLenMax);
          const seg = segments[i % segments.length];
          const startIdx = randInt(0, seg.length-1);
          const chars = Array.from({ length: len }, (_, t) => seg[(startIdx + t) % seg.length]);
          return {
            y: -randInt(0, h),
            speed: rand(minSpeed, maxSpeed),
            len,
            chars,
            seg,
            idx: (startIdx + len) % seg.length
          };
        });

        ctx.font = `${fontSize}px "Courier New", Consolas, monospace`;
        ctx.textBaseline = 'top';
      }

      let last = performance.now();
      function frame(now){
        try {
          const dtRaw = (now - last) / 1000;
          const dt = Math.max(0, Math.min(0.05, isFinite(dtRaw) ? dtRaw : 0.016));
          last = now;

          ctx.fillStyle = `rgba(255,255,255,${fadeStrength})`;
          ctx.fillRect(0,0,canvas.width,canvas.height);

          for (let i=0; i<streams.length; i++){
            const s = streams[i];
            const prevY = s.y;
            s.y += s.speed * dt;

            const x = rightStart + i * columnWidth;
            const prevCell = Math.floor(prevY / fontSize);
            const headCell = Math.floor(s.y   / fontSize);
            const headY = headCell * fontSize;

            if (headCell !== prevCell){
              const nextBit = s.seg[s.idx];
              s.idx = (s.idx + 1) % s.seg.length;
              s.chars.pop();
              s.chars.unshift(nextBit);
            }

            if (headY >= 0 && headY < canvas.height){
              ctx.fillStyle = headColor;
              ctx.fillText(s.chars[0], x, headY);
            }

            for (let t=1; t<s.len; t++){
              const yy = headY - t*fontSize;
              if (yy < -fontSize) break;
              if (yy > canvas.height) continue;
              const op = Math.max(0, 0.7 - (t / s.len) * 0.7);
              ctx.fillStyle = trailColor(op);
              ctx.fillText(s.chars[t], x, yy);
            }

            if (headY - (s.len * fontSize) > canvas.height){
              s.y = -randInt(0, canvas.height);
              s.speed = rand(minSpeed, maxSpeed);
              s.len = randInt(trailLenMin, trailLenMax);
              const seg = segments[(i + randInt(0, segments.length-1)) % segments.length];
              s.seg = seg;
              const startIdx = randInt(0, seg.length-1);
              s.chars = Array.from({ length: s.len }, (_, t) => seg[(startIdx + t) % seg.length]);
              s.idx = (startIdx + s.len) % seg.length;
            }
          }
        } catch (e) {
          console.error('Matrix rain frame error:', e);
          resize();
        }
        requestAnimationFrame(frame);
      }

      resize();
      window.addEventListener('resize', resize, { passive:true });
      requestAnimationFrame((t)=>{ last=t; frame(t); });
    })();
  </script>
</body>
</html>
